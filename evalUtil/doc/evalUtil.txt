                  Eval Util


*** Change this to reflect EvalUtil ***
EvalUtil is a set of functions to help direct the 
evaluation of the genetic engine

Old Documentation. Change this...


1- Motivation: 



The current computer systems we communicate with everyday lack the power 

of being able to adapt to their environment. Thei're programmed in a way 

that all interactions with the outside world follows a representation of

a model devised by a human programmer during the development of the system.

This represetation is static in the sense it can't change during the 

existence of the system in was not previously devided for the system creator. 

Although another system can be constructed to 

correct the perception of the programmer about the changing on the system's

relation with its environment it can't, by itself, change the model 

(or environmental assumptions) that defined its way of reacting to external 

stimulli. It takes us to the problem that, altough the system is the one wich

experiments the human devised model of interaction, it can't take advantage 

of this experience to modify the perceived generational model, and, in this way, 

its relation with the environment in an adaptive manner.



To provide this power, nature has endowed living organisms with a 

powerful adaptation mechanism knows as evolution. The evolutive algorithm 

we have found in nature is a form of achieving continuous adaptation 

to the environment demands on viable living beings.





2- Introduction



Rita is a programming language intended to allow the description of goals a system must attain. Its purpose is to describe the "what" of a system's functionings, not the "how".



In order to describe the intended behavior of a system, the programmer states, using the constructs of Rita laguage, the system objectives, in terms of wanted relations between the system's input and output.



This behavioral description is made in the form of rules



Input -> Output: Credit



Where Input is the perception "scenario", as experienced by the system itself, Output is the intended system action in response. Credit is the value of the rule, stating how important is to attain the objectives of a particular rule, regarding other rules



The Rita language interpreter, now in it's early development stage, is developed in C, in order to be portable to a great number of embedded platforms. It is also intended to be used inside other sytems, to provide adaptation/learning capabilities to those systems.



3 - ADAPTATION

* CONTINUE -> HOW CAN THE SYSTEM ADAPT?

* CONTINUE -> KINDS OF ADAPTIVE SYSTEMS (neural nets, mental states, expert systems, etc...) <-?

* CONTINUE -> HOW CAN THE ADAPTATION BE TRACED?



4 - EVOLUTION

* CONTINUE -> STATE THE PROBLEMS OF EVOLUTIVE SYSTEMS. MAKE CORRELATION WITH PROGRAMMING 

              ALGORITHMS. 

* CONTINUE -> IN NATURE WE HAVE NO PRE-DEFINED MODELS, ONLY LIVING ORGANISM EXPERIENCE





5 - Genetic Algorithms



* CONTINUE -> GENETIC ALGORITHMS HIGH-LEVEL DESCRIPTION

* CONTINUE -> GENETIC ALGORITHMS HISTORY

* CONTINUE -> GENETIC PROGRAMMING

	   -> GENETIC PROGRAMMING HISTORY

	   -> EVALUATION OF GENETIC PROGRAMMING SYSTEMS

	   -> CURRENT STATE OF THE ART



???

???

???



* CONTINUE -> MACHINE EVOLUTIVE SYSTEMS LIMITATIONS (ROBOTICS, PROBLEM BOUNDARIES, ETC)



* CONTINUE -> HOW TO CONNECT EVOLUTION WITH A PRE-DEFINED HUMAN MODEL OF SYSTEM BEHAVIOR (RULES)

???

???

???





We propose here an approach to the problem of creating systems able to adapt to a givem problem/environment while following high level human 

guidelines about what is to be done, not how.



*** CONTINUE ***



 [for this we need to let the systems to communicate with their environment]

 [problems? autonomy? error? unwanted behavior? evolution?]

 [how to control an autonomous evolutive system?]

 [how to assign credit to actions in an evolutive system?]

 [how to make a "symbiosis" of controled behavior and evolved one? how to control evolution?]

 [what is it for? evolving robots, evolution based enhancement of a 

  single unit]

 [no population? how is this possible? inner nets population]

                  



Description: Rita is a language that allows programmers to describe the 

behavior of an evolving computing system in terms of sets of directives 

that define a dynamic relation between the system and its environment. 

These directives guide an evolutive engine. Through the use of the 

directives the programmer can interactively create and evolve a system, 

changing the paths of relations it has with its environment.



Functioning: The system consists of four distinct elements: 

 a) A population of neural networks,

 b) An evolutive engine to continuously evolve the network population, 

 c) A supervisor system that interprets rita directives and defines scores for

    each program, acting as a genetic algorithm for the program set;

 d) The directives set that define the goals of the system in its dynamic 

    relation with the surrounding environment.





Elements description:



 Neural networks:  *** CONTINUE ***

 Evolution engine: *** CONTINUE ***

 Supervisor:       *** CONTINUE ***

 Directives set:         

  The directives set, the Rita language, defines the relation the system must establish between its inputs, 

outputs and internal states. The program is a guide to the evolution of the system, providing 

credit for its actions.





Elements functioning





 Neural networks:  *** CONTINUE ***

 Evolution engine: *** CONTINUE ***

 Supervisor:       *** CONTINUE ***

 Directives set:   *** CONTINUE ***      





Directives definition: the Rita language



*** REVIEW: CHANGE NOTATION TO EBNF ***



Preamble:

  The notation used all along the language documentation is as follows:

  <a>  -> "a" is a literal

  [b]  -> "b" is opcional

  [c]+ -> one or more occurrences of "c"

  [d]* -> zero or more occurrences of "d"

  a / b-> "a" or "b"





0. Comments are defined by a line started with "#"                   



6. Mapping section: input and output identification



1.1   The identifier <iomapping> defines a section in which the output and 

input are identified. 

The inputs and outputs are defined in the order they appear, i.e., the first 

declared input is the first set of bits and so forth.



   Usage: 

          <input>     [ input_identifier  <:> [char |

                                               short int |

                                               int |

                                               long int |

                                               float |

                                               double |

                                               unsigned char |

                                               unsigned short int |

                                               unsigned int |

                                               unsigned long int] ]+

          <ouput>     [ output_identifier <:> [char |

                                               short int |

                                               int |

                                               long int |

                                               float |

                                               double |

                                               unsigned char |

                                               unsigned short int |

                                               unsigned int |

                                               unsigned long int] ]+





7. Rules section: input_configuration -> output_configuration 

                  relation definitions



7.1 The identifier <rules> defines a section in which the system behavioral 

rules are stated. The rules define a mapping from input configuration to 

output configuration.



  usage: <rules> [ rule | rule_block ]+







7.2 the rules statements have the form: statement -> statement : credit. The 

credit for a rule is earned when a program presents an input -> output pair 

that satisfies the rule, that is, the presented input->output

pair is a case of the stated rule.



  usage: input_clause <->> output_clause rule_credit

                                                  [<activate>/<deactivate>

                                                       block_name_variable]



7.3 The input clauses have the form:

    [not]

    input_identifier

      

                    <[>min_range<,>max_range<]>

                    |

                    value

    [

     <and> | <or>

     [<not>]



     input_identifier

      

                     min_range<..>max_range

                     |

                     value

    

    ]*





    |



    <dontcare>



    where: input_identifier 

                    -> unikely identifies an input (declared in the 

                               "input" section)

           operand          

                     -> <and>, <or> and <not>

           <dontcare>       

                     -> the keyword "dontcare" is used when the input 

                        doesn't matter for a given rule.

                        example: we want some output value to be defined

                                        with no regard to any input.

           min_range<..>max_range

                     -> input values range

           value

                     -> input punctual value



   Note1: the evaluation order is left to right and "not" has precedence over

          "and" and "or".

	  example: 

          "a and b or b and not c" evaluates to (((a and b) or b) and (not c))



   Note2: punctual values or elements of a range can be decimal (no prefix), 

          binary (prefix #b), octal (prefix #o) or hexadecimal (prefix #x).

          example: 10, #b10101, #o187, #x0ab9ed.



7.5 The output clauses have the same form of the input ones.

                  

7.6 The "rule credit" value defines the credit that must be given to the 

system when the statement is true and valid. 

It can have a positive or negative value. Positive values are a confirmation 

to the system that the action taken is approved and negative values mean the 

contrary: the action is not approved and should not be taken in the future. 

This is how communication takes place between the Rita language program and 

the evolutionary engine.

    *implementation note*: the credit sum returned will affect the active network

                           that generated the input,output pair captured by 

                           the statements that gives the credit in a sequence of actions.



7.7 The "activate" or "deactivate" part of the rule sets the status of a

block name variable to "true" or "false" respectively. Thus enabling or

disabling the block linked to that variable.



8  Rule block declaration.



8.1 Rule blocks are elements that define boundaries between groups of rules.

It's main purpose is grouping rules and set conditions to their activation.

Any group of rules that isn't in a block is automatically assigned to the

default block. A block is valid depending on its block activation variable.

The block declaration starts with the "block" keywork and ends with the next

block declaration or end of the text.

Blocks have two purposes: rule organization and objective maintenance.



    usage: <block> [block_activation_variable] [rule]+

    Notes: a) Initially the block name variable of every block, but the

              default one, is set automatically to "false".



